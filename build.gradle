/*
 * Bearsampp Module PostgreSQL - Pure Gradle Build
 *
 * This is a pure Gradle build configuration that:
 * 1. Downloads PostgreSQL binaries from modules-untouched repository
 * 2. Extracts and prepares PostgreSQL files
 * 3. Creates release packages with proper structure
 * 4. Generates hash files for verification
 *
 * Usage:
 *   gradle tasks                                - List all available tasks
 *   gradle release -PbundleVersion=17.5         - Build release for specific version
 *   gradle releaseAll                           - Build all available versions
 *   gradle clean                                - Clean build artifacts
 *   gradle info                                 - Display build information
 *   gradle verify                               - Verify build environment
 */

plugins {
    id 'base'
}

// Load build properties from gradle.properties
def buildProps = new Properties()
file('gradle.properties').withInputStream { buildProps.load(it) }

// Project information
group = 'com.bearsampp.modules'
version = buildProps.getProperty('bundle.release', '1.0.0')
description = "Bearsampp Module - ${buildProps.getProperty('bundle.name', 'postgresql')}"

// Define project paths
ext {
    projectBasedir = projectDir.absolutePath
    rootDir = projectDir.parent
    devPath = file("${rootDir}/dev").absolutePath

    // Bundle properties from gradle.properties
    bundleName = buildProps.getProperty('bundle.name', 'postgresql')
    bundleRelease = buildProps.getProperty('bundle.release', '1.0.0')
    bundleType = buildProps.getProperty('bundle.type', 'bins')
    bundleFormat = buildProps.getProperty('bundle.format', '7z')

    // Build paths - with configurable base path
    // Priority: 1) gradle.properties, 2) Environment variable, 3) Default
    def buildPathFromProps = buildProps.getProperty('build.path', '').trim()
    def buildPathFromEnv = System.getenv('BEARSAMPP_BUILD_PATH') ?: ''
    def defaultBuildPath = "${rootDir}/bearsampp-build"

    buildBasePath = buildPathFromProps ?: (buildPathFromEnv ?: defaultBuildPath)

    // Use shared bearsampp-build/tmp directory structure
    buildTmpPath = file("${buildBasePath}/tmp").absolutePath
    bundleTmpBuildPath = file("${buildTmpPath}/bundles_build/${bundleType}/${bundleName}").absolutePath
    bundleTmpPrepPath = file("${buildTmpPath}/bundles_prep/${bundleType}/${bundleName}").absolutePath
    bundleTmpSrcPath = file("${buildTmpPath}/bundles_src").absolutePath

    // Download and extract paths
    bundleTmpDownloadPath = file("${buildTmpPath}/downloads/${bundleName}").absolutePath
    bundleTmpExtractPath = file("${buildTmpPath}/extract/${bundleName}").absolutePath

    // Final build output path
    postgresqlBuildPath = file("${buildBasePath}/${bundleType}/${bundleName}/${bundleRelease}").absolutePath
}

// Verify dev path exists
if (!file(ext.devPath).exists()) {
    throw new GradleException("Dev path not found: ${ext.devPath}. Please ensure the 'dev' project exists in ${ext.rootDir}")
}

// Configure repositories for dependencies
repositories {
    mavenCentral()
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

// Fetch PostgreSQL versions from modules-untouched repository
def fetchModulesUntouchedProperties() {
    def propsUrl = "https://raw.githubusercontent.com/Bearsampp/modules-untouched/main/modules/postgresql.properties"
    try {
        def connection = new URL(propsUrl).openConnection()
        connection.setRequestProperty("User-Agent", "Gradle Build Script")
        connection.setConnectTimeout(10000)
        connection.setReadTimeout(10000)

        def props = new Properties()
        connection.inputStream.withCloseable { stream ->
            props.load(stream)
        }
        return props
    } catch (Exception e) {
        logger.warn("Could not fetch modules-untouched postgresql.properties: ${e.message}")
        return null
    }
}

// Get download URL for a specific PostgreSQL version
def getPostgreSQLDownloadUrl(String version) {
    // First, try to get from modules-untouched
    def untouchedProps = fetchModulesUntouchedProperties()
    if (untouchedProps && untouchedProps.containsKey(version)) {
        return untouchedProps.getProperty(version)
    }

    // Fallback: construct standard URL format
    logger.warn("Version ${version} not found in modules-untouched, using standard URL format")
    return "https://github.com/Bearsampp/modules-untouched/releases/download/postgresql-${version}/postgresql-${version}-windows-x64-binaries.zip"
}

// Download file from URL
def downloadFile(String url, File destFile) {
    println "Downloading from: ${url}"
    println "Destination: ${destFile}"

    destFile.parentFile.mkdirs()

    def connection = new URL(url).openConnection()
    connection.setRequestProperty("User-Agent", "Gradle Build Script")
    connection.setConnectTimeout(30000)
    connection.setReadTimeout(300000)

    def contentLength = connection.getContentLengthLong()
    def downloaded = 0L
    def lastProgress = 0

    destFile.withOutputStream { out ->
        connection.inputStream.withCloseable { input ->
            def buffer = new byte[8192]
            def bytesRead
            while ((bytesRead = input.read(buffer)) != -1) {
                out.write(buffer, 0, bytesRead)
                downloaded += bytesRead

                if (contentLength > 0) {
                    def progress = (int) ((downloaded * 100) / contentLength)
                    if (progress >= lastProgress + 10) {
                        println "  Progress: ${progress}% (${downloaded / 1024 / 1024} MB / ${contentLength / 1024 / 1024} MB)"
                        lastProgress = progress
                    }
                }
            }
        }
    }

    println "  Download complete: ${destFile.name}"
}

// Extract ZIP file
def extractZip(File zipFile, File destDir) {
    println "Extracting: ${zipFile.name}"
    println "To: ${destDir}"

    destDir.mkdirs()

    def zip = new java.util.zip.ZipFile(zipFile)
    try {
        zip.entries().each { entry ->
            def entryFile = new File(destDir, entry.name)
            if (entry.directory) {
                entryFile.mkdirs()
            } else {
                entryFile.parentFile.mkdirs()
                entryFile.withOutputStream { out ->
                    zip.getInputStream(entry).withCloseable { input ->
                        out << input
                    }
                }
            }
        }
    } finally {
        zip.close()
    }

    println "  Extraction complete"
}

// Helper function to find 7-Zip executable
def find7ZipExecutable() {
    // Check environment variable
    def sevenZipHome = System.getenv('7Z_HOME')
    if (sevenZipHome) {
        def exe = file("${sevenZipHome}/7z.exe")
        if (exe.exists()) {
            return exe.absolutePath
        }
    }

    // Check common installation paths
    def commonPaths = [
        'C:/Program Files/7-Zip/7z.exe',
        'C:/Program Files (x86)/7-Zip/7z.exe',
        'D:/Program Files/7-Zip/7z.exe',
        'D:/Program Files (x86)/7-Zip/7z.exe'
    ]

    for (path in commonPaths) {
        def exe = file(path)
        if (exe.exists()) {
            return exe.absolutePath
        }
    }

    // Try to find in PATH
    try {
        def process = ['where', '7z.exe'].execute()
        process.waitFor()
        if (process.exitValue() == 0) {
            def output = process.text.trim()
            if (output) {
                return output.split('\n')[0].trim()
            }
        }
    } catch (Exception e) {
        // Ignore
    }

    return null
}

// Helper function to generate hash files
def generateHashFiles(File file) {
    if (!file.exists()) {
        throw new GradleException("File not found for hashing: ${file}")
    }

    // Generate MD5
    def md5File = new File("${file.absolutePath}.md5")
    def md5Hash = calculateHash(file, 'MD5')
    md5File.text = "${md5Hash} ${file.name}\n"
    println "  Created: ${md5File.name}"

    // Generate SHA1
    def sha1File = new File("${file.absolutePath}.sha1")
    def sha1Hash = calculateHash(file, 'SHA-1')
    sha1File.text = "${sha1Hash} ${file.name}\n"
    println "  Created: ${sha1File.name}"

    // Generate SHA256
    def sha256File = new File("${file.absolutePath}.sha256")
    def sha256Hash = calculateHash(file, 'SHA-256')
    sha256File.text = "${sha256Hash} ${file.name}\n"
    println "  Created: ${sha256File.name}"

    // Generate SHA512
    def sha512File = new File("${file.absolutePath}.sha512")
    def sha512Hash = calculateHash(file, 'SHA-512')
    sha512File.text = "${sha512Hash} ${file.name}\n"
    println "  Created: ${sha512File.name}"
}

// Helper function to calculate hash
def calculateHash(File file, String algorithm) {
    def digest = java.security.MessageDigest.getInstance(algorithm)
    file.withInputStream { stream ->
        def buffer = new byte[8192]
        def bytesRead
        while ((bytesRead = stream.read(buffer)) != -1) {
            digest.update(buffer, 0, bytesRead)
        }
    }
    return digest.digest().collect { String.format('%02x', it) }.join('')
}

// Helper function to get available versions
def getAvailableVersions() {
    def versions = []

    // Check bin directory
    def binDir = file("${projectDir}/bin")
    if (binDir.exists()) {
        def binVersions = binDir.listFiles()
            ?.findAll { it.isDirectory() && it.name.startsWith(bundleName) && it.name != 'archived' }
            ?.collect { it.name.replace(bundleName, '') } ?: []
        versions.addAll(binVersions)
    }

    // Check bin/archived subdirectory
    def archivedDir = file("${projectDir}/bin/archived")
    if (archivedDir.exists()) {
        def archivedVersions = archivedDir.listFiles()
            ?.findAll { it.isDirectory() && it.name.startsWith(bundleName) }
            ?.collect { it.name.replace(bundleName, '') } ?: []
        versions.addAll(archivedVersions)
    }

    // Remove duplicates and sort
    return versions.unique().sort()
}

// ============================================================================
// GRADLE TASKS
// ============================================================================

// Task: Display build information
tasks.register('info') {
    group = 'help'
    description = 'Display build configuration information'

    def projectName = project.name
    def projectVersion = project.version
    def projectDescription = project.description
    def gradleVersion = gradle.gradleVersion
    def gradleHome = gradle.gradleHomeDir

    doLast {
        println """
        ================================================================
                Bearsampp Module PostgreSQL - Build Info
        ================================================================

        Project:        ${projectName}
        Version:        ${projectVersion}
        Description:    ${projectDescription}

        Bundle Properties:
          Name:         ${bundleName}
          Release:      ${bundleRelease}
          Type:         ${bundleType}
          Format:       ${bundleFormat}

        Paths:
          Project Dir:  ${projectBasedir}
          Root Dir:     ${rootDir}
          Dev Path:     ${devPath}
          Build Path:   ${postgresqlBuildPath}
          Build Base:   ${buildBasePath}
          Tmp Path:     ${buildTmpPath}
          Prep Path:    ${bundleTmpPrepPath}
          Download Path: ${bundleTmpDownloadPath}
          Extract Path: ${bundleTmpExtractPath}

        Java:
          Version:      ${JavaVersion.current()}
          Home:         ${System.getProperty('java.home')}

        Gradle:
          Version:      ${gradleVersion}
          Home:         ${gradleHome}

        Available Task Groups:
          * build        - Build and package tasks
          * help         - Help and information tasks
          * verification - Verification and validation tasks

        Quick Start:
          gradle tasks                              - List all available tasks
          gradle info                               - Show this information
          gradle release -PbundleVersion=17.5       - Build release for version
          gradle releaseAll                         - Build all versions
          gradle clean                              - Clean build artifacts
          gradle verify                             - Verify build environment
        """.stripIndent()
    }
}

// Task: Main release task - builds a specific PostgreSQL version
tasks.register('release') {
    group = 'build'
    description = 'Build release package for a specific version (interactive or use -PbundleVersion=X.X.X)'

    // Capture property at configuration time
    def versionProperty = project.findProperty('bundleVersion')

    doLast {
        def versionToBuild = versionProperty

        if (!versionToBuild) {
            // Interactive mode - prompt for version
            def availableVersions = getAvailableVersions()

            if (availableVersions.isEmpty()) {
                throw new GradleException("No versions found in bin/ directory")
            }

            println ""
            println "=".multiply(70)
            println "Interactive Release Mode"
            println "=".multiply(70)
            println ""
            println "Available versions:"

            // Show versions with location tags
            def binDir = file("${projectDir}/bin")
            def archivedDir = file("${projectDir}/bin/archived")

            availableVersions.eachWithIndex { version, index ->
                def location = ""
                if (binDir.exists() && file("${binDir}/${bundleName}${version}").exists()) {
                    location = "[bin]"
                } else if (archivedDir.exists() && file("${archivedDir}/${bundleName}${version}").exists()) {
                    location = "[bin/archived]"
                }
                println "  ${(index + 1).toString().padLeft(2)}. ${version.padRight(15)} ${location}"
            }
            println ""
            println "Enter version to build (index or version string):"
            println ""

            // Read input using Gradle's standard input
            def input = null
            try {
                def reader = new BufferedReader(new InputStreamReader(System.in))
                input = reader.readLine()
            } catch (Exception e) {
                throw new GradleException("""
                    Failed to read input. Please use non-interactive mode:
                      gradle release "-PbundleVersion=X.X.X"

                    Available versions: ${availableVersions.join(', ')}
                """.stripIndent())
            }

            if (!input || input.trim().isEmpty()) {
                throw new GradleException("""
                    No version selected. Please use non-interactive mode:
                      gradle release "-PbundleVersion=X.X.X"

                    Available versions: ${availableVersions.join(', ')}
                """.stripIndent())
            }

            def cleaned = input.trim()

            // Accept either an index (1..N) or an explicit version string
            if (cleaned.isInteger()) {
                def idx = cleaned.toInteger()
                if (idx < 1 || idx > availableVersions.size()) {
                    throw new GradleException("""
                        Invalid selection index: ${cleaned}

                        Please choose a number between 1 and ${availableVersions.size()} or enter a version string.
                    """.stripIndent())
                }
                versionToBuild = availableVersions[idx - 1]
            } else {
                versionToBuild = cleaned
                // Validate the entered version string exists
                if (!availableVersions.contains(versionToBuild)) {
                    throw new GradleException("""
                        Invalid version: ${versionToBuild}

                        Please choose from available versions:
                        ${availableVersions.collect { "  - ${it}" }.join('\n')}
                    """.stripIndent())
                }
            }
        }

        println ""
        println "=".multiply(70)
        println "Building release for ${bundleName} version ${versionToBuild}..."
        println "=".multiply(70)
        println ""

        // Check if bundle path exists in bin directory
        def bundlePath = file("${projectDir}/bin/${bundleName}${versionToBuild}")
        if (!bundlePath.exists()) {
            // Try archived directory
            bundlePath = file("${projectDir}/bin/archived/${bundleName}${versionToBuild}")
        }

        if (!bundlePath.exists()) {
            def availableVersions = getAvailableVersions()
            def versionList = availableVersions.isEmpty() ? "  (none found)" : availableVersions.collect { "  - " + it }.join('\n')

            throw new GradleException("""
                Bundle version not found: ${bundleName}${versionToBuild}
                
                Available versions in bin/:
                ${versionList}
                
                To see all available versions from modules-untouched:
                  gradle listReleases
            """.stripIndent())
        }

        println "Bundle path: ${bundlePath}"
        println ""

        // Get the bundle folder and version
        def bundleFolder = bundlePath.name
        def bundleVersion = bundleFolder.replace(bundleName, '')

        // Get download URL from modules-untouched
        def downloadUrl = getPostgreSQLDownloadUrl(bundleVersion)
        println "Download URL: ${downloadUrl}"
        println ""

        // Prepare download directory
        def downloadDir = file(bundleTmpDownloadPath)
        downloadDir.mkdirs()

        // Download PostgreSQL binaries
        def downloadFileName = downloadUrl.substring(downloadUrl.lastIndexOf('/') + 1)
        def downloadFile = file("${downloadDir}/${downloadFileName}")

        if (!downloadFile.exists()) {
            println "Downloading PostgreSQL ${bundleVersion}..."
            this.downloadFile(downloadUrl, downloadFile)
            println ""
        } else {
            println "Using cached download: ${downloadFile.name}"
            println ""
        }

        // Extract PostgreSQL binaries
        def extractDir = file("${bundleTmpExtractPath}/${bundleFolder}")
        if (!extractDir.exists()) {
            println "Extracting PostgreSQL binaries..."
            extractZip(downloadFile, extractDir)
            println ""
        } else {
            println "Using cached extraction: ${extractDir}"
            println ""
        }

        // Find pgsql directory
        def pgsqlDir = file("${extractDir}/pgsql")
        if (!pgsqlDir.exists()) {
            throw new GradleException("pgsql directory not found in extracted files: ${extractDir}")
        }

        // Check if pg_ctl.exe exists
        def pgCtlExe = file("${pgsqlDir}/bin/pg_ctl.exe")
        if (!pgCtlExe.exists()) {
            throw new GradleException("pg_ctl.exe not found at ${pgCtlExe}")
        }

        println "Source folder: ${pgsqlDir}"
        println ""

        // Prepare output directory
        def postgresqlPrepPath = file("${bundleTmpPrepPath}/${bundleName}${bundleVersion}")
        postgresqlPrepPath.mkdirs()

        // Copy PostgreSQL files (excluding unnecessary files)
        println "Copying PostgreSQL files..."
        copy {
            from pgsqlDir
            into postgresqlPrepPath
            exclude 'bin/pgAdmin*'
            exclude 'doc/**'
            exclude 'include/**'
            exclude 'pgAdmin*/**'
            exclude 'StackBuilder/**'
            exclude 'symbols/**'
            exclude '**/*.lib'
            exclude '**/*.pdb'
        }

        // Copy configuration files from bin directory
        println "Copying configuration files..."
        copy {
            from bundlePath
            into postgresqlPrepPath
        }

        println ""
        println "Prepared files in: ${postgresqlPrepPath}"
        println ""

        // Create archive
        def destFile = "bearsampp-${bundleName}-${bundleVersion}-${bundleRelease}"
        def archiveFile = file("${postgresqlBuildPath}/${destFile}.${bundleFormat}")

        if (archiveFile.exists()) {
            delete archiveFile
        }

        println "Creating archive..."
        if (bundleFormat == '7z') {
            def sevenZip = find7ZipExecutable()
            if (!sevenZip) {
                throw new GradleException("7-Zip not found. Please install 7-Zip or set 7Z_HOME environment variable.")
            }

            def command = [
                sevenZip,
                'a',
                '-t7z',
                archiveFile.absolutePath,
                "${postgresqlPrepPath.name}/*"
            ]

            def process = command.execute(null, postgresqlPrepPath.parentFile)
            process.consumeProcessOutput(System.out, System.err)
            def exitCode = process.waitFor()

            if (exitCode != 0) {
                throw new GradleException("7-Zip compression failed with exit code: ${exitCode}")
            }
        } else {
            // Use Gradle's built-in ZIP task
            tasks.create(name: "zipArchive${bundleVersion}", type: Zip) {
                from postgresqlPrepPath.parentFile
                include "${postgresqlPrepPath.name}/**"
                destinationDirectory = archiveFile.parentFile
                archiveFileName = archiveFile.name
            }.execute()
        }

        println "Archive created: ${archiveFile}"
        println ""

        // Generate hash files
        println "Generating hash files..."
        generateHashFiles(archiveFile)

        println ""
        println "=".multiply(70)
        println "[SUCCESS] Release build completed successfully for version ${versionToBuild}"
        println "Output directory: ${postgresqlPrepPath}"
        println "Archive: ${archiveFile.absolutePath}"
        println "=".multiply(70)
    }
}

// Task: Build all available versions
tasks.register('releaseAll') {
    group = 'build'
    description = 'Build release packages for all available versions in bin/ directory'

    doLast {
        def binDir = file("${projectDir}/bin")
        if (!binDir.exists()) {
            throw new GradleException("bin/ directory not found")
        }

        def versions = getAvailableVersions()

        if (versions.isEmpty()) {
            throw new GradleException("No versions found in bin/ directory")
        }

        println ""
        println "=".multiply(70)
        println "Building releases for ${versions.size()} ${bundleName} versions"
        println "=".multiply(70)
        println ""

        def successCount = 0
        def failedVersions = []

        versions.each { version ->
            println "=".multiply(70)
            println "[${successCount + 1}/${versions.size()}] Building ${bundleName} ${version}..."
            println "=".multiply(70)

            try {
                // Execute release task for this version
                project.ext.bundleVersion = version
                tasks.getByName('release').actions.each { action ->
                    action.execute(tasks.getByName('release'))
                }

                println ""
                println "[SUCCESS] ${bundleName} ${version} completed"
                successCount++

            } catch (Exception e) {
                println ""
                println "[FAILED] ${bundleName} ${version}: ${e.message}"
                failedVersions.add(version)
            }

            println ""
        }

        // Summary
        println "=".multiply(70)
        println "Build Summary"
        println "=".multiply(70)
        println "Total versions: ${versions.size()}"
        println "Successful:     ${successCount}"
        println "Failed:         ${failedVersions.size()}"

        if (!failedVersions.isEmpty()) {
            println ""
            println "Failed versions:"
            failedVersions.each { v ->
                println "  - ${v}"
            }
        }

        println "=".multiply(70)

        if (failedVersions.isEmpty()) {
            println "[SUCCESS] All versions built successfully!"
        } else {
            throw new GradleException("${failedVersions.size()} version(s) failed to build")
        }
    }
}

// Task: Enhanced clean task
tasks.named('clean') {
    group = 'build'
    description = 'Clean build artifacts and temporary files'

    doLast {
        // Clean Gradle build directory
        def buildDir = file("${projectDir}/build")
        if (buildDir.exists()) {
            delete buildDir
        }

        // Clean module build directory
        def moduleBuildDir = file(postgresqlBuildPath)
        if (moduleBuildDir.exists()) {
            delete moduleBuildDir
        }

        println "[SUCCESS] Build artifacts cleaned"
    }
}

// Task: Verify build environment
tasks.register('verify') {
    group = 'verification'
    description = 'Verify build environment and dependencies'

    doLast {
        println "Verifying build environment for module-postgresql..."

        def checks = [:]

        // Check Java version
        def javaVersion = JavaVersion.current()
        checks['Java 8+'] = javaVersion >= JavaVersion.VERSION_1_8

        // Check required files
        checks['gradle.properties'] = file('gradle.properties').exists()

        // Check dev directory
        checks['dev directory'] = file(devPath).exists()

        // Check bin directory
        checks['bin directory'] = file("${projectDir}/bin").exists()

        // Check 7-Zip if format is 7z
        if (bundleFormat == '7z') {
            checks['7-Zip'] = find7ZipExecutable() != null
        }

        // Check network connectivity to modules-untouched
        def untouchedProps = fetchModulesUntouchedProperties()
        checks['modules-untouched access'] = untouchedProps != null

        println "\nEnvironment Check Results:"
        println "-".multiply(60)
        checks.each { name, passed ->
            def status = passed ? "[PASS]" : "[FAIL]"
            println "  ${status.padRight(10)} ${name}"
        }
        println "-".multiply(60)

        def allPassed = checks.values().every { it }
        if (allPassed) {
            println "\n[SUCCESS] All checks passed! Build environment is ready."
            println "\nYou can now run:"
            println "  gradle release -PbundleVersion=17.5   - Build release for version"
            println "  gradle listVersions                    - List available versions"
        } else {
            println "\n[WARNING] Some checks failed. Please review the requirements."
            
            if (!checks['7-Zip']) {
                println "\n7-Zip Installation:"
                println "  Download from: https://www.7-zip.org/"
                println "  Or set 7Z_HOME environment variable to 7-Zip installation directory"
            }
            
            if (!checks['modules-untouched access']) {
                println "\nmodules-untouched Access:"
                println "  Check your internet connection"
                println "  URL: https://github.com/Bearsampp/modules-untouched"
            }
            
            throw new GradleException("Build environment verification failed")
        }
    }
}

// Task: List all bundle versions from modules-untouched postgresql.properties
tasks.register('listReleases') {
    group = 'help'
    description = 'List all available releases from modules-untouched postgresql.properties'

    doLast {
        def props = fetchModulesUntouchedProperties()
        if (!props) {
            println "\n[WARNING] Could not fetch modules-untouched postgresql.properties."
            println "No release information available."
            return
        }

        println "\nAvailable PostgreSQL Releases (modules-untouched):"
        println "-".multiply(80)
        props.sort { a, b -> a.key <=> b.key }.each { version, url ->
            println "  ${version.padRight(10)} -> ${url}"
        }
        println "-".multiply(80)
        println "Total releases: ${props.size()}"
    }
}

// Task: List available bundle versions in bin and bin/archived directories
tasks.register('listVersions') {
    group = 'help'
    description = 'List all available bundle versions in bin/ and bin/archived/ directories'

    doLast {
        def versions = getAvailableVersions()

        if (versions.isEmpty()) {
            println "\nNo versions found in bin/ or bin/archived/ directories"
            return
        }

        println "\nAvailable ${bundleName} versions:"
        println "-".multiply(60)

        // Show which directory each version is in
        def binDir = file("${projectDir}/bin")
        def archivedDir = file("${projectDir}/bin/archived")

        versions.each { version ->
            def location = ""
            if (binDir.exists() && file("${binDir}/${bundleName}${version}").exists()) {
                location = "[bin]"
            } else if (archivedDir.exists() && file("${archivedDir}/${bundleName}${version}").exists()) {
                location = "[bin/archived]"
            }
            println "  ${version.padRight(15)} ${location}"
        }
        println "-".multiply(60)
        println "Total versions: ${versions.size()}"

        if (!versions.isEmpty()) {
            println "\nTo build a specific version:"
            println "  gradle release -PbundleVersion=${versions.last()}"
        }
    }
}

// Task: Validate gradle.properties
tasks.register('validateProperties') {
    group = 'verification'
    description = 'Validate gradle.properties configuration'

    doLast {
        println "Validating gradle.properties..."

        def required = ['bundle.name', 'bundle.release', 'bundle.type', 'bundle.format']
        def missing = []

        required.each { prop ->
            if (!buildProps.containsKey(prop) || buildProps.getProperty(prop).trim().isEmpty()) {
                missing.add(prop)
            }
        }

        if (missing.isEmpty()) {
            println "[SUCCESS] All required properties are present:"
            required.each { prop ->
                println "    ${prop} = ${buildProps.getProperty(prop)}"
            }
        } else {
            println "[ERROR] Missing required properties:"
            missing.each { prop ->
                println "    - ${prop}"
            }
            throw new GradleException("build.properties validation failed")
        }
    }
}

// Task: Check modules-untouched integration
tasks.register('checkModulesUntouched') {
    group = 'verification'
    description = 'Check modules-untouched repository integration and available versions'

    doLast {
        println ""
        println "=".multiply(70)
        println "Modules-Untouched Integration Check"
        println "=".multiply(70)
        println ""

        def propsUrl = "https://raw.githubusercontent.com/Bearsampp/modules-untouched/main/modules/postgresql.properties"
        println "Repository URL:"
        println "  ${propsUrl}"
        println ""

        println "Fetching postgresql.properties from modules-untouched..."
        def untouchedProps = fetchModulesUntouchedProperties()

        if (untouchedProps) {
            println ""
            println "=".multiply(70)
            println "Available Versions in modules-untouched"
            println "=".multiply(70)

            def sortedVersions = untouchedProps.sort { a, b ->
                // Simple version comparison
                def aParts = a.key.tokenize('.')
                def bParts = b.key.tokenize('.')
                for (int i = 0; i < Math.min(aParts.size(), bParts.size()); i++) {
                    try {
                        def aNum = aParts[i].replaceAll(/[^0-9]/, '').toInteger()
                        def bNum = bParts[i].replaceAll(/[^0-9]/, '').toInteger()
                        if (aNum != bNum) return aNum <=> bNum
                    } catch (Exception e) {
                        // If parsing fails, compare as strings
                        if (aParts[i] != bParts[i]) return aParts[i] <=> bParts[i]
                    }
                }
                return aParts.size() <=> bParts.size()
            }

            sortedVersions.each { version, url ->
                println "  ${version.padRight(10)}"
            }

            println "=".multiply(70)
            println "Total versions: ${untouchedProps.size()}"
            println ""

            println ""
            println "=".multiply(70)
            println "[SUCCESS] modules-untouched integration is working"
            println "=".multiply(70)
            println ""
            println "Version Resolution Strategy:"
            println "  1. Check modules-untouched postgresql.properties (remote)"
            println "  2. Construct standard URL format (fallback)"
            println ""

        } else {
            println ""
            println "=".multiply(70)
            println "[WARNING] Could not fetch postgresql.properties from modules-untouched"
            println "=".multiply(70)
            println ""
            println "This may be due to:"
            println "  - Network connectivity issues"
            println "  - Repository access problems"
            println "  - File not available at expected location"
            println ""
            println "The build system will fall back to:"
            println "  1. Standard URL format construction"
        }
    }
}

// ============================================================================
// BUILD LIFECYCLE HOOKS
// ============================================================================

gradle.taskGraph.whenReady { graph ->
    println """
    ================================================================
      Bearsampp Module PostgreSQL - Pure Gradle Build
    ================================================================
    """.stripIndent()
}

// ============================================================================
// DEFAULT TASK
// ============================================================================

defaultTasks 'info'
